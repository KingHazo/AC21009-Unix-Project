#!/bin/bash

#this file is designed in a manner to either be called from a PATH variable directory or by absolute path to have a user keep only one
#copy of the file and allow the creation project folders on the fly without having to copy this file into them

#in order to handle permissions in the system we will only allow the initialising user, and so the admin of the project
#to perform actions like remove the .gip directory or load up a past archive
function init() {
    # Check if the metadata directory already exists
    if [ -d "./.gip" ]; then
        echo "project folder is already initialised"
  	exit 0;
    fi

    # Create the metadata directories
    mkdir "./.gip"
    mkdir "./.gip/locks"
    mkdir "./.gip/archives"

    #create file for logging user actions
    touch "./.gip/log"
    log "$USER created project repository, and is now administrator of the project"

    #create workspace area
    mkdir "./workspaces"
    mkdir "./workspaces/$USER"

    echo "project repository is initialised"

    #change security permissions to only allow the administrator write permissions
    chmod 755 "./.gip"
}

#takes in one parameter as input and appends it to the log file on a new line with a timestamp
function log() {
    local timestamp=$(date +"%Y-%m-%d %T")
    local log_file=./.gip/log
    echo "$timestamp: $1" >> "$log_file"
}


#takes a file name as input and either commits the changes you've made to said file in your directory and unlocks
#it's usage for others or it creates a blank file in the project directory
function checkin_file() {

    #if file doesn't exist, inform the user or create it if a flag has been passed to create a file
    if [ ! -e $1 ]; then
	if [ "$2" = "-c" ]; then
	    touch $1;
	    log "$USER has checked in new file '$1'"
	    exit 0;
	fi
	echo "file '$1' does not exist"
	exit 0;
    fi

    #check for a lock file, if it does not exist the file is not checked out and cannot be checked in
    #first we will disable the lock, and then copy the file into the main project directory to overwrite the differences
    #and lastly create links to the file in each persons working directory to reflect the differences in other users workspaces
    local lock_file="./.gip/locks/$1.lock"

    if [ -e "$lock_file" ]; then
	if [ ! "$(cat $lock_file)" = $USER ]; then
	    echo "file is checked out by a different user"
        fi
        # Remove the lock file to indicate that the file is no longer being edited
        rm "$lock_file"
	changes=$(diff $1 "./workspaces/$USER/$1")
	mv "./workspaces/$USER/$1" "./$1"
        log "$USER has checked in '$1' after making changes:\n$changes"
	exit 0;
    else
        echo "File '$1' is not checked out"
    fi
}

#if a user needs a file for a program but does not want to check it out for editing
#they can use gip link to have a link to the file in their workspace
#takes a file name as input and links it to the calling user's workspace
function link {
	#if the file doesn't exist, cannot link to it
	if [ ! -e $1 ]; then
	    echo "file '$1' not found and cannot link to it"
	    return 1;
	fi

	#if a link already exists, cannot link to it
	if [ -h "./workspaces/$USER/$1" ]; then
	    echo "link already exists in your workspace"
	    return 2;
	fi

	ln "./workspaces/$USER/$1" "./../../$1"
}

#takes in one input in the form of a filename and tries to remove that file
function remove() {
    #if the file is currently checked out, abort
    local lock_file="./.gip/locks/$1.lock"

    if [ -f $lock_file ]; then
	local result=$(ls -l .gip/locks/ | grep ".*$1\.lock$" | cut -d " " -f 3)
	echo -e "File '$1' is currently being edited by $result and thus cannot be removed"
        return 1;
    fi

    #if the file does not exist, cannot erase if
    if [ ! -e $1 ]; then
	echo "file '$1' does not exist"
    fi

    rm $1
    log "file '$1', has been removed by $USER"
}


function checkout_file() {
    local lock_file="./.gip/locks/$1.lock"

    #if file does not exist tell the user
    if [ ! -e $1 ]; then
	echo "File '$1' does not exist in project directory"
	return 1;
    fi
    if [ -e "$lock_file" ]; then
	local result=$(ls -l .gip/locks/ | grep ".*$1\.lock$" | cut -d " " -f 3)
	echo -e "File '$1' is already being edited by $result"
	return 2;
    fi
    # Create the lock file to indicate that the file is being edited and make a copy in the users workspace
    touch "$lock_file"
    echo $USER > $lock_file

    #
    if [ -h "./workspaces/$USER/$1" ]; then
	rm "./workspaces/$USER/$1"
    fi
    cp $1 "./workspaces/$USER/$1"
    log "$USER has checked out '$1' for editing."
}


#This may be completely atypical to the rest of the design but bear with me (I secretly do not know what I'm doing)
#File name given as variable $3, path as $2
function import() {
    echo "Importing file $3 from filepath $2"
    #If file already exists in working repository
    if [[ -e "$3" ]];
    then
        echo "A file of that name already exists in the project directory"
    #Check if file exists, if so, copy file to project directory
    elif [[ -e "$2/$3" ]];
    then
        cp $3 ./
    else
        echo "The file '$3' cannot be found in the file system"
    fi
}

if [ "$1" = "init" ]; then
    init
    exit 0
fi

if ! [ -d "./.gip" ]; then
    echo "this is not a project root directory, move to the root directory of a project or use git init to initialise this directory"
    exit 0;
fi

case $1 in
    "checkout")
        if [ $# -lt 2 ]; then
            echo "Usage: gip checkout <file_name>"
        else
            checkout_file "$2"
        fi;;
    "checkin")
        if [ $# -lt 2 ]; then
            echo "Usage: gip checkin <file_name> [-c]"
        else
            checkin_file "$2" "$3"
        fi;;
    "import")
	if [ $# -lt 3 ]; then
	    echo "Usage: gip import <file_path> <file_name>"
        else
            import "$2" "$3"
        fi;;
    "remove")
	if [ $# -lt 2 ]; then
	    echo "Usage: gip remove <file_name>"
	else
	    remove "$2"
	fi;;
    "link")
	if [ $# -lt 2 ]; then
	    echo "Usage: gip link <file_name>"
	fi;;
    *)
        echo "Usage: gip <command>"
        echo "Commands:"
        echo "  init                 Initialize the main directory for repositories"
        echo "  checkout <file_name> Checkout a file from the main directory to your workspace"
        echo "  checkin  <file_name> Check in a file from your workspace to the main directory"
        echo "  import   <file_path> <file_name> Import a pre-existing file to the working directory"
        echo "  remove   <file_name> Remove a currently non-checked out file";;
esac

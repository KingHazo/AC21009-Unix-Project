#!/bin/bash

#this file should be in a path variable directory so that it can be accessed from anywhere, only requires one
#copy of the file and allows the users to create project folders on the fly without having to copy this file into their
#project folder. For these reasons the idea of a global config file or directory sharing information on all the
#repositories as I assume you are implying through the implementation of the switch repo function is unnecessary
#as we only need to see if the user is in a project folder through checking if the current directory contains
#".gip" directory

function init() {
    # Check if the metadata directory already exists
    if [ -d "./.gip" ]; then
        echo "project folder is already initialised"
  	exit 0;
    fi
    # Create the metadata directories
    mkdir "./.gip"
    mkdir "./.gip/locks"
    mkdir "./.gip/archives"

    #create file for logging user actions
    touch "./.gip/log"
    log "$USER created project repository"

    #create workspace area
    mkdir "./workspaces"
    mkdir "./workspaces/$USER"

    echo "project repository is initialised"

    #change security permission for root directory to not allow users to alter it without using gip
    chmod 555 ./workspaces
    chmod 555 ./
}

#instead of adding and removing files, we'll make the project directory inaccesible through direct means
#we'll add directories for users as workspaces and ask users the files they want to check out from the main directory
#to work on and make non-writable for others, if they add files in their workspace we'll make the files be added automatically
#to the project directory after they checkin the file and commit their changes

function log() {
    local timestamp=$(date +"%Y-%m-%d %T")
    local log_file=./.gip/log
    echo "$timestamp: $1" >> "$log_file"
}

function checkout_file() {
    local lock_file="./.gip/locks/$1.lock"

    if [ ! -e $1 ]; then
	echo "File does not exist in project directory, check the spelling of the file or check in a new file in your workspace and commit changes"
    elif [ -e "$lock_file" ]; then
	local result=$(ls -l .gip/locks/ | grep ".*$1\.lock$" | cut -d " " -f 3)
	echo -e "File '$1' is already being edited by $result"
    else
        # Create the lock file to indicate that the file is being edited and make a copy in the users workspace
        touch "$lock_file"
	rm "./workspaces/$USER/$1"
	cp $1 "./workspaces/$USER/$1"
	chmod 774 "./workspaces/$USER/$1"
        log "$USER has checked out '$1' for editing."
    fi
}

#takes a file name as input and either commits the changes you've made to said file in your directory and unlocks
#it's usage for others or it creates a blank file in the project directory
function checkin_file() {

    #if file doesn't exist, create it
    if [ ! -e $1 ]; then
	chmod 775 ./;
	touch $1;
	chmod 444 $1;
	chmod 555 ./;
	log "$USER has checked in new file '$1'"
	exit 0;
    fi

    #if the file does exist, you should be checking it in after making changes
    #first we will disable the lock, and then copy the file into the main project directory to overwrite the differences
    #and lastly create links to the file in each persons working directory to reflect the differences in other users workspaces
    local lock_file="./.gip/locks/$1.lock"

    if [ -e "$lock_file" ]; then
        # Remove the lock file to indicate that the file is no longer being edited
        rm "$lock_file"
	chmod 775 ./
	changes=$(diff $1 "./workspaces/$USER/$1")
	# apply the new file contents to the shared directory
	chmod 775 $1
	mv "./workspaces/$USER/$1" "./$1"
	chmod 444 $1
        log -e "$USER has checked in '$1' after making changes:\n$changes"
	chmod 555 ./
	#create links of this file to each workspace directory to make
	#reading files in workspaces and compilation in workspaces function
	#if the link already exists ignore it
	for workspace in $(ls ./workspaces)
	do
	    if [  ]; then
		ln -s -t "./workspaces/$workspace/" ./../../$1
	    fi
	done
    else
        echo "File '$1' is not checked out by anyone"
    fi
}

#while checking in a file can account for adding it, checking a file out is not able to account
#for removing a file without several complications, so deletion will have a dedicated function that
#alleviates that difficulty by making the checks be as simple as "does the file exist?" and
#"is the file currently checked out?"
function remove() {
    #if the file is currently checked out, abort
    local lock_file="./.gip/locks/$1.lock"

    if [ -f lock_file ]; then
	local result=$(ls -l .gip/locks/ | grep ".*$1\.lock$" | cut -d " " -f 3)
	echo -e "File '$1' is currently being edited by $result and thus cannot be removed"
        return 0
    fi
}

if [ "$1" = "init" ]; then
    init
    exit 0
fi

if ! [ -d "./.gip" ]; then
    echo "this is not a project root directory, move to the root directory of a project or use git init to initialise this directory"
    exit 0;
fi

case $1 in
    "checkout")
        if [ $# -lt 2 ]; then
            echo "Usage: gip checkout <file_name>"
        else
            checkout_file "$2"
        fi;;
    "checkin")
        if [ $# -lt 2 ]; then
            echo "Usage: gip checkin <file_name>"
        else
            checkin_file "$2"
        fi;;
    "import")
	if [ $# -lt 2 ]; then
	    echo "Usage: gip import <file_path>"
    	fi;;
    "remove")
	if [ $# -lt 2 ]; then
	    echo "Usage: gip remove <file_name>"
	else
	    remove $2
	fi;;
    *)
        echo "Usage: gip <command>"
        echo "Commands:"
        echo "  init                Initialize the main directory for repositories"
        echo "  create <repo_name>  Create a new repository with the specified name";;
esac
